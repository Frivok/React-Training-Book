import React from "react";

// Here’s an example of a simple React component that returns some JSX:
export function Hello() {
  return <span>Hello!</span>;
}

export function World() {
  return <span>World</span>;
}

export function HelloWorld() {
  return (
    <div>
      <Hello /> <World />!
    </div>
  );
}

// And here is the JavaScript generated by the Babel compiler:
export function HelloBabel() {
  return React.createElement("span", {}, "Hello!");
}

// The React.createElement function signature looks like this:

/*React.createElement(
  string|element,
  [propsObject],
  [children...]
)
The string|element can be a string describing an HTML or SVG tag (like 'div' or 'span'), or it can be a component a.k.a. function (like HelloWorld, with no quotes).

The propsObject and children are optional, and you can also supply more than one child by passing additional arguments:*/

// You can also nest the calls:
export function ManyChildren() {
  return React.createElement(
    "div",
    {},
    React.createElement("div", {}, "Child1"),
    React.createElement(
      "div",
      {},
      "Child2",
      React.createElement("div", {}, "Child2_child")
    )
  );
}

// Try it yourself! Rewrite the HelloWorld component to call React.createElement instead of returning JSX.
export function HelloFrogs() {
  return React.createElement("h1", {}, "Hello Frogs ,", "Whats up");
}

// Here is a slightly more complicated bit of JSX, and a preview of what’s to come. You can see that it references a function parameter named props. We haven’t talked about props yet, but this is the way you pass arguments to React components.
export function SongName(props) {
  return <span className="song-name">{props.song.name}</span>;
}

// And here is what it compiles to
export function SongNameComplile(props) {
  return React.createElement(
    "span",
    { className: "song-name" },
    props.song.name
  );
}

// this jsx:
export function HelloArray() {
  // Better equivalent which doesn't needs keys
  // React.Children.toArray([<Hello />, <World />]);
  return [<Hello key="loler" />, <World key="cater" />];
}

// would turn into this js
// (notice the brackets)
export function HelloJs() {
  return [React.createElement(Hello, null), React.createElement(World, null)];
}

export function NameCells() {
  return (
    <React.Fragment>
      <td>First Name</td>
      <td>Last Name</td>
    </React.Fragment>
  );
}
// After rendering, the React.Fragment component will “disappear”, leaving only the children inside it, so that the DOM structure will have no wrapper components. Fragments make it easier to produce valid HTML (such as keeping <td> elements directly inside <tr>s), and they keep the DOM structure flatter which makes it easier to write semantic HTML (which is also usually more accessible HTML).

export function NameSyntax() {
  return (
    <>
      <td>First Name</td>
      <td>Last name</td>
    </>
  );
}
// This <></> syntax is the preferred way to write fragments, and this feature will be available as long as you’re working in a new-enough project (Babel 7+, Create React App 2+)

/* JavaScript in JSX
You can insert real JavaScript expressions inside JSX code, and in fact, you’ll do this quite often. Surround JavaScript with single braces like this:*/
export function SubmitButton() {
  const buttonLabel = "Submit";
  return <button>{buttonLabel}</button>;
}

/*“If” in JSX
The next question you might wonder is, “How do I write a conditional if I can’t use ‘if’?” There are a couple of options.
The first is the ternary operator (the question mark, ?). Use it like this:*/
export function ValidIndicator() {
  const isValid = true;
  return <span>{isValid ? "valid" : "not valid"}</span>;
}

/*You can also use boolean operators such as && like this:*/
export function ValidBoolean() {
  const isValid = true;
  return (
    <span>
      {isValid && "valid"}
      {!isValid && "not valid"}
    </span>
  );
}

export function KostaBank() {
  "BE17 3630 9860 8321";
}
